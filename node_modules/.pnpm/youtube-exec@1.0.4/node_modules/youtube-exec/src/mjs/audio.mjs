#!/usr/bin/env node
// =====================================( youtube-exec: Unleash the Power of YouTube Downloads! )=============================================
// ðŸŒŸ Once upon a time in the vast realm of the Internet, a remarkable tool was born: YOUTUBE-EXEC. ðŸ“½ï¸âœ¨
//
// ðŸŽ¥ Step into a world where you can effortlessly download the mesmerizing audio and captivating video content from YouTube. ðŸŽµðŸŽ¬ðŸ’½
// ðŸ’¡ Powered by the mighty and ingenious "youtube-dl-exec" library, this tool possesses the uncanny ability to extract the finest details from YouTube's vast kingdom of videos. ðŸ“šðŸ”ðŸ’¡
// âš™ï¸ Equipped with the seamless and reliable "fluent-ffmpeg" library, youtube-exec embarks on a quest to fetch files with utmost precision and grace.
// With each step, it transforms the abstract bits and bytes into a symphony of sights and sounds. ðŸ”„âš™ï¸ðŸ”Š
// ðŸŒŸ Unlock the gates to a realm where your favorite audio harmonies and video treasures await.
// Dive into the enchanting world of YouTube's vast library, and let your imagination soar. ðŸŽ‰ðŸ”‘ðŸ’Ž
// ðŸ”“ Embrace the freedom to break free from limitations and embrace a world of boundless possibilities.
// Bid farewell to the boundaries that once held you back and embark on an adventure beyond your wildest dreams. ðŸš«ðŸŒðŸ”“ðŸ’«
// ðŸ“– This is the tale of youtube-exec, a tool that empowers you to shape your own narrative in the realm of YouTube.
//  Let your journey begin! ðŸš€ðŸŽ¬ðŸ”¥
//
// =====================================( youtube-exec by magneum )=============================================
import progLogger from "progress-estimator";
import logger from "../../utils/logger.mjs";
import youtubedl from "youtube-dl-exec";
import ffmpeg from "fluent-ffmpeg";
import urlRegex from "url-regex";
import readline from "readline";
const plogger = progLogger();
import chalk from "chalk";
import path from "path";
import fs from "fs";

const createFolderIfNotExists = (folder) => {
  if (!folder) {
    folder = "youtube-exec";
  }
  const outputFolder = path.resolve(process.cwd(), folder);
  if (!fs.existsSync(outputFolder)) {
    fs.mkdirSync(outputFolder);
   
  }
};

const fetchAudioDetails = async ({ url, quality }) => {
 
  try {
    const promise = youtubedl(url, {
      dumpSingleJson: true,
      noCheckCertificates: true,
      noWarnings: true,
      preferFreeFormats: true,
      addHeader: ["referer:youtube.com", "user-agent:googlebot"],
    });
    const result = await plogger(promise, "â³ Obtaining...");
    const videoTitle = result.title;
    const reqAudio = findReqAudioFormat(result.formats, quality);
    return { reqAudio, videoTitle };
  } catch (err) {
   
    throw err;
  }
};

const findReqAudioFormat = (formats, quality) => {
  let reqAudio = null;
 
  if (quality === "best") {
    let highestBitrate = 0;
    for (let i = 0; i < formats.length; i++) {
      const format = formats[i];
      if (format.acodec === "none" || format.vcodec !== "none") {
        continue;
      }
      const bitrate = format.tbr || format.abr;
      if (bitrate && bitrate > highestBitrate) {
        highestBitrate = bitrate;
        reqAudio = format;
      }
    }
    return reqAudio;
  } else if (quality === "lowest") {
    let lowBitrate = Infinity;
    for (let i = 0; i < formats.length; i++) {
      const format = formats[i];
      if (format.acodec === "none" || format.vcodec !== "none") {
        continue;
      }
      const bitrate = format.tbr || format.abr;
      if (bitrate && bitrate < lowBitrate) {
        lowBitrate = bitrate;
        reqAudio = format;
      }
    }
    return reqAudio;
  } else {
   
    throw new Error("Error: Audio Quality supported: best,lowest");
  }
};

const downloadAudioFile = async (ffmpegUrl, outputFile, quality, filename) => {
  let outputFilename;
  if (filename) {
    outputFilename = filename;
  } else {
    const videoTitle = path.basename(ffmpegUrl, path.extname(ffmpegUrl));
    outputFilename = `${videoTitle}`;
  }
  outputFile = path.join(outputFile, `${outputFilename}.mp3`);

  return new Promise((resolve, reject) => {
    const ffmpegCommand = ffmpeg()
      .input(ffmpegUrl)
      .audioBitrate(320)
      .toFormat("ipod")
      .on("start", () => {
       
      })
      .on("progress", (progress) => {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0);
        process.stdout.write(`â¬‡ï¸ Downloading: ${progress.percent}%`);
      })
      .on("end", () => {
        console.log(`file_name: ${outputFilename}.mp3`);
         
        resolve();
      })
      .on("error", (err) => {
        readline.clearLine(process.stdout, 0);
        readline.cursorTo(process.stdout, 0);
       
        reject(err);
      })
      .saveToFile(outputFile);
    ffmpegCommand.run();
  });
};

const validateUrl = (url) => {
  const regex = urlRegex({ strict: false });
  return regex.test(url);
};

const displayAudioDetails = (reqAudio, videoTitle, url) => {
  
  Object.entries(reqAudio).forEach(([key, value]) => {
    switch (key) {
      case "url":
        url = value;
        break;
      case "fragments":
      
        value.forEach((fragment, index) => {
         
          Object.entries(fragment).forEach(([fKey, fValue]) => {
         
          });
        });
        break;
      default:
       
        break;
    }
  });
  return url;
};

const dlAudio = ({ url, folder, quality, filename }) => {
  return new Promise(async (resolve, reject) => {
    try {
      if (!validateUrl(url)) {
       
        throw new Error("Invalid URL format.");
      }
      const { reqAudio, videoTitle } = await fetchAudioDetails({
        url,
        quality,
      });
      if (reqAudio) {
        url = displayAudioDetails(reqAudio, videoTitle, url);
        if (!folder) {
          folder = "youtube-exec";
        }
        createFolderIfNotExists(folder);
        let outputFilename;
        if (filename) {
          outputFilename = `${filename}`;
        } else {
          outputFilename = `${videoTitle}`;
        }
        await downloadAudioFile(url, folder, quality, outputFilename);
      } else {
       
      }
      resolve();
    } catch (err) {
     
      reject(err);
    }
  });
};

export default dlAudio;
